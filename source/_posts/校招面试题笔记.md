---
title: 校招面试题笔记
date: 2018-09-01 09:36:42
tags: [Java]
categories: [Java基础知识]
---

本文记录在校招中经常遇到的面试问题。

<!-- more -->

# 计算机网络

* 计算机网络分为哪几层？
  计算机网络如果是 OSI 模型的话，分为七层。从下到上依次是：1、物理层，2、数据链路层，3、网络层，4、传输层，5、会话层，6、表示层，7、应用层。
  TCP／IP 协议簇模型的话，分为四层。1、网络接口层，2、网际层IP，3、传输层，4、应用层。
  **各层的作用**
  * 应用层:应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。应用层交互的数据单元称为报文。
  * 传输层:传输层的任务是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。
  * 网络层:网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报。
  * 数据链路层:数据链路层简称链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻的节点之间传输数据时，数据链路层将网络层交下的IP数据报组装成帧，在两个相邻节点间的链路上传送帧，每一帧包括数据和必要的控制信息。
  * 物理层:物理层上传送的数据单位是比特。物理层的作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异，使其上的数据链路层不必考虑网络的具体传输介质是什么。
* TCP 和 UDP 有什么区别？什么场景使用 TCP，什么场景什么 UDP？哪些应用层协议使用了 TCP，哪些使用了 UDP？
  传输层在面试的时候是最常被问到的，这一块需要好好看。TCP 和 UDP 最主要的区别是 TCP 是可靠传输的，UDP 是不可靠传输的。所以如果我们的发送消息之类的场景，因为你要确保用户的消息不会丢失，需要使用 TCP 协议。如果你是在进行视频聊天或者看直播，那你可以使用 UDP 协议，因为即使几个画面丢失了，对用户来说影响也不是很大。
  * 用户数据报协议 UDP (User Datagram Protocol) 是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一 和 多对多的交互通信。
  * 传输控制协议 TCP (Transmission Control Protocol)是面向连接的，提供可靠交付，有流量控制、拥塞控制、提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是一对一的（点对点）。
  哪些应用层协议使用 TCP，哪些使用 UDP ?
  使用TCP协议的应用层服务: HTTP FTP SMTP TELNET POP3 Finger NNTP IMAP4
  使用UDP协议的应用层服务: DHCP NTP TFTP BOOTP
* 什么是窗口滑动协议
  * TCP利用滑动窗口实现流量控制机制。
  * 滑动窗口是一种流量控制机制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据，但有两种特殊情况：一种情况是可以发送紧急数据，例如，允许用户终止远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。
  流量控制
  * TCP利用滑动窗口实现流量控制。
  * 流量控制是为了控制发送方发送速率，保证接收方来得及接收。
  * 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口的大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。
* 慢开始、拥塞避免、快重传、快恢复
  TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传、快恢复。
  * 慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据注入到网络中，那么可能会引起网络堵塞，因为现在还不知道网络的实际情况。较好的做法是先探测一下，即由小到大逐渐增大发送窗口。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
  * 拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送的cwnd加1
  为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：
  当 cwnd < ssthresh 时，使用上述的慢开始算法。
  当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
  当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。
  无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。
  {% asset_img img03.jpg %}
  * 快重传和快恢复：
  * 快重传算法：要求接收方每收到一个失序的报文段后立即发出重复确认（为的是让发送方及早知道有报文段没有到达对方）而不是等到自己发送数据时才进行捎带确认。接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。
  {% asset_img img04.jpg %}
  * 快恢复算法：当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞，接下来把cwnd设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法，是拥塞窗口缓慢地线性增加。
  {% asset_img img05.jpg %}
* TCP连接三次握手，四次挥手

## TCP 的三次握手

以客户端 A 与服务器 B 用三次握手建立 TCP 连接为例：

* 首先服务器 B 处于 LISTEN(监听)状态，等待客户端的连接请求。
* 客户端 A 向服务器 B发送连接请求报文，SYN=1,ACK=0,选择一个初始的序号x.
* 服务器 B 收到连接请求报文，如果同意建立连接，则向客户端 A 发送连接确认报文，SYN=1,ACK=1,确认号为x+1,初始的序号为y.
* 客户端 A 收到服务器 B 的连接确认报文后，还要向服务器 B 发送确认，确认号为y+1,序号为 x+1。
* 服务器 B 收到客户端 A 的确认后，连接建立。

### **三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器打开连接。

客户端发送的连接请求可能会在网络中滞留，客户端等待一个超时重传时间之后，就会重新发送连接请求。但是这个滞留的连接请求可能最后还是会到达服务器，如果不进行第三次握手，那么服务器就会打开连个连接。如果有第三次握手，客户端就会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## TCP 的四次挥手

* 客户端 A 发送连接释放报文，FIN=1.
* 服务器 B 收到之后发送确认，此时 TCP 处于半关闭状态，服务器B 能向客户端 A 发送数据，但是客户端 A 不能向服务器 B 发送数据。
* 当服务器 B 不再需要连接时，发送连接释放报文，FIN=1.
* 客户端 A 收到之后发送确认，进入 TIME_WAIT 状态，等待2 MSL(最大报文存活时间)后释放连接。
* 服务器 B 收到客户端 A的确认后释放连接。

### 四次挥手的原因

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进人了 CLOSE-WAIT 状态。这个状态是为了让服务器发送还未传送完的数据，传送完毕之后，服务器就会发送 FIN 连接释放报文。

### TIME_WAIT

客户端收到服务器的FIN连接释放报文，发送确认后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间，2MSL。这样做的原因：

* 确保最后一个确认报文能够到达服务器。如果服务器B 没有收到客户端 A发送来的确认报文，那么就会重新发送连接释放请求报文，客户端 A 等待一段时间就是为了处理这种情况的发生。
* 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的链接不会出现旧的连接请求报文。

* 当你输入域名访问一个网站的时候，背后的过程是什么？
  这个问题是比较开放的，你可以回答的内容有很多，但是你如果回答得越详细肯定是越好的。第一步就是域名解析，域名解析的话你可以说一下域名缓存在哪些地方，然后如果你域名在本地没有缓存的话，是如何通过 DNS 来进行域名解析的，如果你的 DNS 服务器上没有保存那个域名，那你的 DNS 服务器将如何处理来得到这个域名的 ip。第二步就是说一下 TCP 连接的三次握手的过程。其他拓展内容有很多可以说，看你知识储备。例如你可以说通过 CDN 来进行访问加速。也可以说目前网站基本上都是前后端分离的，访问的时候会先访问反向代理服务器进行负载均衡之类的.
* HTTP 和 HTTPS 协议, https 协议用到了哪种密钥？
  
  HTTP: 超文本传输协议，被用在web游览器和服务器之间传递信息，HTTP 协议以明文方式发送内容，不提供任何方式的数据加密。如果攻击者截取了游览器和服务器之间的通信数据，就可以读懂其中的信息。因此，HTTP 协议不适合传输一些敏感信息，例如：银行卡账户，密码等重要数据。
  HTTP 有以下安全性问题：1.使用明文进行通信，内容可能会被窃听；2.不验证通信方的身份，通信方的身份有可能遭遇伪装；3.无法证明报文的完整性，报文有可能遭篡改。
  HTTPS: 安全套接字超文本传输协议，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议， HTTPS 协议依靠证书来验证服务器的身份，并对服务器和游览器之间的通信进行加密，用到的密钥有对称密钥和非对称密钥。HTTPs 采用混合的加密机制，把对称密钥作为消息内容,使用非对称密钥加密传输来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。通信开始时，客户端需要使用服务器的公开密钥将对称密钥传输给服务器，之后再进行对称密钥加密。
* 状态码
  
  1XX: 信息性状态码         接收的请求正在处理
  2XX: 成功状态码           请求正常处理完毕
  3XX: 重定向状态码         需要进行附加操作以完成请求
  4XX: 客户端错误状态码      服务器无法处理请求
  5XX: 服务器错误状态码      服务器处理请求出错
* 什么是 socket？
  
  socket 是用来进行网络通信的，java 里面已经有封装好这个类了，分为客户端和服务器，通过 ip + 端口来进行访问。
  socket通常也称作"套接字"，应用程序通常通过"套接字"向网络发出请求或者应答网络请求。Socket和ServerSocket类库位于java .net包中。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在 客户端 而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。
* SOCKET连接过程
  
  根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。
  服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。
  客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
  连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
* 什么是 IO，什么是 NIO，什么是 AIO，什么是 netty 框架？
  NIO 就是非阻塞 IO，用来解决上面读取消息的时候会阻塞的问题。在 jdk1.4 左右引入的，是通过 selector、buffer、通道等组件来实现的
  AIO 就是异步非阻塞 IO。咱们上面说的 NIO 是同步阻塞 IO。AIO 是异步的，NIO 是同步的。同步和异步是什么区别我有点讲不清楚，如果这个你不懂自己去查一下资料。异步基本上就是通过回调来实现的。AIO 是在 jdk1.7 左右引入的，面试官问 AIO 一般也会问得比较少。
  netty 是用来实现非阻塞 IO 的一个框架，这个作为拓展点，感兴趣可以去了解一下。

  {% asset_img img01.png %}

# 操作系统

* 进程和线程的区别是什么？
  
  进程是具有一定独立功能的程序在某一个数据集上的一次运行活动。进程是系统进行资源分配和调度的基本单元，线程是进程的一个实体，是 CPU 调度的基本单元，它是比进程更小的能独立运行的基本单位。
  一个进程可以包含多个线程。
  线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
  一个线程可以创建和撤销另外一个线程，同一个进程中的线程可以并发执行。
  相对进程而言，线程更加接近执行体的概念，它可以与同进程的线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
  1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
  2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
  3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
  4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
  5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
* 进程间通信的方式有什么？线程间通信的方式有什么？
  
  进程间通信方式主要有以下7中：

 1）管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。
 2）有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。
 3）信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
 4）消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
 5）信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
 6）共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
 7）套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。
 线程间通信主要有以下几种（线程间通信的主要目的是用于线程同步）：
 1、锁机制
     1.1 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。
     1.2 读写锁：允许多个线程同时读共享数据，而对写操作互斥。
     1.3 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
2、信号量机制：包括无名线程信号量与有名线程信号量
3、信号机制：类似于进程间的信号处理。
4、直接共享变量也行，通过管道也行。

* 什么是缓存？有哪些缓存的更新算法？
  
  缓存是一种广义的概念，在计算机存储层次结构中，低一层的存储器都可以看做是高一层的缓存。比如Cache是内存的缓存，内存是硬盘的缓存，硬盘是网络的缓存等等。
  最近最少使用（LRU，Least Recently Used）算法：算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。
* 你用过什么 linux 命令？
  
  基本上命令例如 cd、ps，vim 之类的。。。

# 数据库

* 数据库常用的操作
  
  现场面试的话，有时候是会被要求手写 SQL 的，所以对于 groupBy，orderBy，子查询之类的基础肯定是要会的。。。
* 什么是左连接，什么是右连接，什么是全连接，什么是内连接？
  
  左连接where只影向右表，右连接where只影响左表。
  左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据,简言之 Left Join影响到的是右边的表
  右连接后的检索结果是tbl2的所有数据和tbl1中满足where 条件的数据,简言之 Right Join影响到的是左边的表。
  内连接：两张表中都有的数据才会显示
  全连接：两张表中所有数据都显示

* 数据库的事务有哪些特性？
  
  主要有四个特性，ACID，原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation)、持久性 (Durability)。如果你觉得这四个特性你无法理解的话，你直接背下来这四个词就行了，然后对隔离性做深入一点的理解，其他的基本上不会被问。

* 数据库中的隔离等级有哪些？
  
  数据库事务的隔离等级有4个，由低到高依次为：读未提交(read uncommited)、读已提交(read commited)、可重复读(repeatable read)、可串行化(serializable)，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。**sql server和oracle默认隔离级别是 read commited, mysql默认隔离级别是 repeatable read**
  脏读：如果一个事务2读取了另一个事务1修改的值，但是最后事务1回滚了，那么事务2就读取了一个脏数据，这也就是所谓的脏读。
  不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
  幻读 （Phantom Read）:第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

* 数据库的索引有什么作用？用什么来实现的？
  
  索引是用来加快查找速度的。目前在数据库中一般是使用 B + 树来实现索引的。
* B 树和 B + 树有什么区别？为什么索引不用 B 树
  
  总体上来说，B + 树在非叶子结点不保存数据，只在叶子结点保存。而 B 树在叶子结点和非叶子结点都会保存。这种结构导致你如果用 B 树来进行查询，会增加磁盘 IO 的次数，导致性能不如 B + 树。
* 什么是乐观锁，什么是悲观锁？
  
  悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

  乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

  两种锁的使用场景：从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

* SQL 编译的过程大概是什么样的？（这一点可不看，算是偏门）
  存储过程是会在数据库中先进行编译的，所以你使用存储过程直接调用就可以了。而你如果直接写一堆的 SQL 语句的话，比存储过程多了一个编译的过程，所以存储过程性能好一点。然后由这个问题延伸出来一个有意思的问题。如果你了解过一些网络安全方面的知识，那你应该就听过 SQL 注入攻击。防止 SQL 注入，在 jdbc 中一种有效的方法就是使用 prepareStatement，prepareStatement 其实就是使用了预编译的方式来防止 SQL 注入的。

# 数据结构与算法

* 数据结构的话，链表，树，图的基本知识得懂
* 了解树的先序遍历，中序遍历，后序遍历。图的广度优先搜索算法，深度优先搜索算法。
* 如果你是准备笔试算法题的话，我建议你先刷剑指 offer，然后再去刷 leetCode。刷的时候一定要直接在编辑器上写代码，不要用任何 ide，因为有些笔试环境就是不允许你使用 ide 的。而且你如果是线下笔试，还需要直接在纸上写。所以，一定不要用任何 IDE 写算法题。
* 算法题中的重点应该是动态规划，主要是因为动态规划如果你能够找得到状态转移方程的话，那么代码行数会比较少的，所以动态规划适合被当作笔试题，这个要重点准备。

# java 知识

* java 运行时数据区域如何划分的？
  
  运行时数据区域主要划分为五个区域: 堆、方法区、程序计数器、虚拟机栈、本地方法栈。
  垃圾回收主要就是针对堆区来进行的，堆区又会被划分为新生代、老年代、永久代（JDK1.8 元空间 metaspace）

* 双亲委托机制
  
  好处：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

* java 的垃圾回收算法有哪些？垃圾回收器有哪些？不同的垃圾回收器有什么区别？
  
  垃圾回收算法有:1.标记清除 2.标记回收 3.复制算法 4.分代回收（一般将堆分为新生代和老年代，新生代使用复制算法，老年代使用标记清除或标记整理）。

  垃圾回收器最常被问的就是 CMS 、 G1，scavage 之类的回收器基本上不问。CMS 和 G1的不同：1.堆空间分配不同 2.压缩策略不同 3.可预测停顿 4.GC策略不同

* voliatile 和 synchonized 有什么区别？synchonized 和 jdk 提供的 Lock 包又有什么区别？

  voliatile 只能够保证可见性和有序性，不能保证原子性，synchonized 是通过加锁来防治出现并发问题。
  jdk 提供的 Lock 包相比于 synchozied 提供了更加多样化的锁机制。
* HashMap 的原理是什么
  
  hashmap 如何实现动态扩容，hashmap 并不是线程安全的，在哪些情况下会出现线程安全的问题？那么哪一个提供了线程安全的 map？他的锁机制是如何实现的？（它的锁机制并不是简单地直接把函数给锁住，而是通过分段来治理的，还是很有意思的）
* 常用的设计模式有哪些？
  
  这个地方你最少有说得出来单例模式、工厂模式、代理模式等，这些都是很常见的设计模式，而且这个问题也经常被问。
* Spring 的 AOP、IOC 作用是什么？如何实现的。
  
  Spring 是一个 java web 的框架，面试官特别喜欢问。但是问 spring 基本上也只围绕着这几个点。
  第一个是 AOP、IOC 的作用是什么，这个问题查一下就知道了。
  第二个是 AOP、IOC 是通过什么实现的？AOP 是通过代理模式来实现的，IOC 是通过单例模式 + 工厂模式来实现的。问得比较多的是 AOP 的实现方式，你如果回答代理模式一般就够了。作为拓展，你可以回答里面用到了动态代理，动态代理有两种方式，一种是 jdk 提供的，一种是 cglib。。。然后你和面试官比较一下两种动态代理的区别，我觉得也是会有加分的。







