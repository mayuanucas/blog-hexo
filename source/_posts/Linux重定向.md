---
title: Linux重定向
date: 2017-11-24 17:41:33
tags: linux
categories: linux
---

本文记录下 Linux 系统中经常使用到的重定向等用法。

<!-- more -->

### 前言知识
```shell
shell 上：

0 表示标准输入
1 表示标准输出
2 表示标准错误输出

> 默认是标准输出重定向，与 1> 相同

2>&1 是指 把 标准错误输出 重定向到 标准输出。
&>file 是指 把 标准输出 和 标准错误输出 都重定向到文件 file 中。

```

### 详细解释

1. &>file 或者是 n>&m 都是一个独立的重定向符号，不要分开来理解。
2. &>file 表示重定向标准输出和标准错误输出到文件。
3. n>&m 表示使文件描述符 n 成为 输出文件描述符 m 的副本。

### 给个例子
shell中可能经常能看到：
```shell
命令 >/dev/null 2>&1
```

分解这个组合：“>/dev/null 2>&1” 为五部分。

1: > 代表重定向到哪里，例如：echo "123" > /home/123.txt

2: /dev/null 代表空设备文件

3: 2> 表示stderr标准错误

4: & 表示等同于的意思，2>&1，表示2的输出重定向等同于1

5: 1 表示stdout标准输出，系统默认值是1，所以">/dev/null"等同于 "1>/dev/null"

因此，>/dev/null 2>&1
也可以写成“1> /dev/null 2>&1”

那么本语句执行过程为：

1>/dev/null ：首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。

2>&1 ：接着，标准错误输出重定向 到 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。

### 最常用的方式有：
```shell

command > file 2>file  与command > file 2>&1

```

它们有什么不同的地方吗？

首先command > file 2>file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command  > file 2>file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道。

而command >file 2>&1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容。

从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会command > file 2>&1 这样的写法。
