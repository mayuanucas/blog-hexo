---
title: JAVA解惑-十六进制的趣事
date: 2018-10-09 19:20:48
tags: [java]
categories: [JAVA解惑]
---

JAVA解惑-十六进制的趣事
<!-- more -->

## 十六进制的趣事

下面的程序是对两个十六进制(hex)字面量进行相加,然后打印出十六进制的结果.这个程序会打印什么呢?

```java
public static void main(String[] args){
    // 输出 cafebabe
    System.out.println(Long.toHexString(0x100000000L + 0xcafebabe));
}
```

看起来该程序应该打印出 **1cafebabe**.毕竟,这确实是十六进制数字的和,该程序使用的是 long 型运算,可以支持16位十六进制数,因此运算溢出是不可能的.

但是实际运行发现,打印的是**cafebabe**,并没有任何的前导的1.这个输出表示的是正确结果的低32位.发生了什么?

十进制字面常量有个很好的属性,即所有的十进制字面常量都是正的! 而十六进制或是八进制字面常量并不具备这个属性!

书写一个负的十进制常量,可以使用一元取反操作符(-)连接一个十进制字面常量.但是十六进制和八进制字面量却不是这样.如果十六进制和八进制字面常量的最高位被置位了,那么它们就是负数.在这个程序中,数字0xcafebabe 是一个int 常量,它的最高位被置位了,所以它是一个负数.它等于十进制数值 -889275714.

## 解决方案

该程序执行的加法是混合类型的计算,左操作数是 long 类型的,而右操作数是 int 类型的.为了执行该计算, Java 将 int 类型的数值用拓宽转换提升为一个 long 类型,然后对两个 long 类型数值相加.
因为int是一个有符号的整数类型,所以这个转换执行的是符号扩展,它将负的 int 类型的数值提升为一个在数值上相等的 long 类型数值.

右操作数 0xcafebabe 被提升为了long 类型的数值 0xffffffffcafebabeL. 这个数值之后被加到了左操作数0x100000000L 上.

```java
  0xffffffffcafebabeL
+ 0x0000000100000000L
---------------------
  0x00000000cafebabeL
```

修正该程序的做法是,用 long 类型十六进制字面常量表示右操作数即可.

```java
public static void main(String[] args){
    // 输出 1cafebabe
    System.out.println(Long.toHexString(0x100000000L + 0xcafebabeL));
}
```

**总结:混合类型的计算可能会产生混淆,尤其是十六进制和八进制字面常量无需显示的减号符号就可以表示负的数值!**